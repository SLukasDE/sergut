/* Copyright (c) 2016 Tobias Koelsch
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include "sergut/detail/JavaClassGeneratorBase.h"

#include "sergut/SerializationException.h"

#include <cassert>
#include <map>

namespace sergut {
namespace detail {

static
const char* toString(const sergut::XmlValueType vt) {
  switch(vt) {
  case sergut::XmlValueType::Attribute:
    return "javax.xml.bind.annotation.XmlAttribute";
  case sergut::XmlValueType::Child:
    return "javax.xml.bind.annotation.XmlElement";
  case sergut::XmlValueType::SingleChild:
    throw SerializationException("SingleChild not supported by JAXB");
  }
  assert(false);
}

static void streamNonGeneric(std::ostream& ostr, const std::map<std::string, detail::NameSpace>& seenTypeNames, const detail::TypeName& currentTypeName)
{
  const auto it = seenTypeNames.find(currentTypeName.typeName);
  if(it != seenTypeNames.cend() && currentTypeName.nameSpace != it->second) {
    // the typename has been imported from another namespace already, so we
    // have to fully qualify it
    ostr << currentTypeName;
  } else {
    ostr << currentTypeName.typeName;
  }
}

static void streamTypeName(std::ostream& ostr, const std::map<std::string, detail::NameSpace>& seenTypeNames, const detail::TypeName& currentTypeName)
{
  const bool isCollection = currentTypeName.collectionType != detail::TypeName::CollectionType::None;
  if(isCollection) {
    streamNonGeneric(ostr, seenTypeNames, currentTypeName.toCollectionType());
    ostr << '<';
  }
  streamNonGeneric(ostr, seenTypeNames, isCollection ? currentTypeName.toElementType() : currentTypeName);
  if(isCollection) {
    ostr << '>';
  }
}

static std::string toUpper(std::string str) {
  if(!str.empty()) {
    str[0] = toupper(str[0]);
  }
  return str;
}

std::string JavaClassGeneratorBase::getPath() const
{
  std::string ret;
  for(const std::string& pathComponent: typeName.nameSpace) {
    if(!ret.empty()) {
      ret += "/";
    }
    ret += pathComponent;
  }
  if(!ret.empty()) {
    ret += "/";
  }
  ret += typeName.typeName + ".java";
  return ret;
}

const char*JavaClassGeneratorBase::toJavaIntType(const uint64_t maxVal)
{
  if(maxVal > std::numeric_limits<int64_t>::max()) {
    return "java::math::BigInteger";
  }
  if(maxVal > std::numeric_limits<int32_t>::max()) {
    return "long";
  }
  if(maxVal > std::numeric_limits<int16_t>::max()) {
    return "int";
  }
  if(maxVal > std::numeric_limits<int8_t>::max()) {
    return "short";
  }
  return "byte";
}

std::ostream& operator<<(std::ostream& ostr, const JavaClassGeneratorBase& cls)
{
  const detail::NameSpace& nameSpace = cls.typeName.nameSpace;

  ostr << "// This file has been generated by SerGut\n"
          "// Manual changes to this file are likely to be lost!\n\n";
  if(!nameSpace.empty()) {
    ostr << "package " << nameSpace << ";\n\n";
  }

  std::map<std::string, detail::NameSpace> seenTypeNames;
  for(const detail::Member& member: cls.members) {
    if(member.typeName.collectionType != detail::TypeName::CollectionType::None) {
      const detail::TypeName collType = member.typeName.toCollectionType();
      auto it = seenTypeNames.find(collType.typeName);
      if(it == seenTypeNames.end() || !it->second.empty()) {
        // take the type in java.lang in case there is no clash with a class in the global namespace
        seenTypeNames[collType.typeName] = collType.nameSpace;
      }
    }
    if(member.typeName.nameSpace.empty()) {
      // overwrite others that might already be in there
      seenTypeNames[member.typeName.typeName] = member.typeName.nameSpace;
    } else {
      auto it = seenTypeNames.find(member.typeName.typeName);
      if(it == seenTypeNames.end()) {
        // set this if the typeName has no entry, yet
        seenTypeNames[member.typeName.typeName] = member.typeName.nameSpace;
      } else if(!it->second.empty() && member.typeName.nameSpace == nameSpace) {
        // overwrite, if the other is not from the global namespace and we are in the current package
        it->second = member.typeName.nameSpace;
      }
    }
  }

  for(const auto memberTypes: seenTypeNames) {
    if(!memberTypes.second.empty() && memberTypes.second != nameSpace) {
      ostr << "import " << memberTypes.second << '.' << memberTypes.first << ";\n";
    }
  }

  ostr << "\n"
          "@javax.xml.bind.annotation.XmlRootElement\n"
          "class " << cls.typeName.typeName << " {\n";

  for(const detail::Member& member: cls.members) {
    ostr << '\t';
    streamTypeName(ostr, seenTypeNames, member.typeName);
    ostr << ' ' << member.memberName << ";\n";

    ostr << "\t@" << toString(member.xmlValueType) << '\n';
    ostr << "\tpublic void set" << toUpper(member.memberName) << "(";
    streamTypeName(ostr, seenTypeNames, member.typeName);
    ostr << " val) {\n"
            "\t\tthis." << member.memberName << " = val;\n"
            "\t}\n"
            "\tpublic ";
    streamTypeName(ostr, seenTypeNames, member.typeName);
    ostr << " get" << toUpper(member.memberName) << "() {\n"
                                << "\t\treturn this." << member.memberName << ";\n"
                                << "\t}\n\n";
  }
  ostr << "}\n";
  return ostr;
}

} // namespace detail
} // namespace sergut
